# docker-compose for local development.
# Uses settings tailored for quick builds and verbose output.
# Rebuilds the app upon detecting source code changes.
version: "3.8"
services:
    client-dev:
        build:
            context: ./client/
            # use the .dev image definition. It is well suited for local development.
            dockerfile: Dockerfile.dev 
        volumes:
          # Make client source code visible to the container. Whenever you make a copy in
          # client/, the image will see it and rebuild the app.
          - ./client:/app
          # This volume tells our app to use the container's variant of node_modules.
          # If you look at client/Dockerfile, you'll notice that it installs dependencies from package.json
          # to /app/node_modules. In the line above, we've shadowed the /app folder with a local, non-docker
          # copy of ./client. This volume tells our image to ignore our shadowing for node_modules.
          # (TLDR: we only have to invoke `npm install` inside the container, not outside of it).
          - /app/node_modules
        ports:
            - "8080:8080"
    server-dev:
        build:
            context: ./server/
            dockerfile: Dockerfile
        volumes:
          # Same as above.
          # See comments in client-dev for details.
          # There's no anonymous volume for node_modules, because the server has no dependencies (yet).
          - ./server:/app
        ports:
            - "3000:3000"
